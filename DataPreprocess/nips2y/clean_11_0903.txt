abstract execut order block comput instruct make differ run time factor two order achiev best possibl speed compil use heurist schedul appropri specif architectur implement howev heurist schedul time consum expens build paper present result use rollout reinforc learn construct heurist schedul basic block rollout schedul outperform commerci schedul reinforc learn schedul perform almost well commerci schedul introduct although high level code gener written go execut sequenti mani modern comput pipelin allow simultan issu multipl instruct order take advantag featur schedul need reorder instruct way preserv semant origin high level code execut quickli possibl effici schedul produc speedup execut factor two howev build schedul arduou process architect develop new comput must manual develop special instruct schedul time chang made propos system build schedul automat save time money allow architect explor design space thoroughli use accur metric evalu design moss et al show iupervis learn techniqu induc excel basic block instruct schedul digit alpha processor although supervis learn method perform quit well share sever limit supervis learn requir exact input output pair gener train pair requir optim schedul search everi valid permut instruct within basic block save optim permut schedul smallest run time howev search time consum perform block mcgovern moss struction optim instruct schedul np hard use semi supervis method reinforc learn rollout requir gener train pair method appli larger basic block train without know optim schedul domain overview moss et al gave full descript domain studi present overview necessari detail experiment method detail result rollout reinforc learn focus schedul basic block instruct version dec digit alpha processor site basic block set instruct singl entri point singl exit point schedul could reorder instruct within basic block could rewrit add remov instruct goal schedul find least cost valid order instruct cost defin simul execut time block valid order one preserv semant necessari order constraint origin code insur valid creat depend graph directli repres necessari order relationship graph direct acycl graph dag alpha dual issu machin two differ execut pipelin dual issu occur number detail condit hold two instruct match two pipelin instruct take anywher one mani ten cycl execut research digit publicli avail simul also includ heurist schedul basic block call schedul dec simul give run time given schedul block assum memori refer hit cach resourc avail begin block schedul use greedi algorithm schedul instruct built schedul sequenti begin end backtrack order test schedul algorithm use spec benchmark program ten program written fortran contain mostli float point calcul eight program written focu integ string pointer calcul program compil use commerci digit compil highest level optim call schedul output compil orig collect basic block contain instruct rollout rollout form mont carlo search first introduc tesauro galperin use backgammon bertseka et al explor rollout domain proven import theoret result instruct schedul domain rollout work follow suppos schedul come point partial schedul set one candid instruct add schedul candid schedul append partial schedul follow fix polici schedul remain instruct schedul complet schedul evalu run time return stochast rollout repeat mani time instruct achiev measur averag expect outcom roll candid schedul pick one best averag run time first set rollout experi compar three differ rollout polici theori develop bertseka et al prove use dec schedul would perform wors dec architect propos new machin might good heurist avail use also consid polici like avail first random polici random choic clearli alway avail polici rollout make choic randomli also use schedul straight line code use rl rollout order produc optim compil orig denot orig last rollout polici test dec schedul denot dec schedul perform one rollout per candid instruct use orig tr dec determinist use rollout random perform number rollout candid instruct chose instruct best averag run time baselin schedul also schedul block randomli run time increas quadrat number rollout focus rollout experi one program spec suit applu tabl give perform rollout schedul compar dec schedul basic block size less applu assess perform rollout polici use ratio weight execut time rollout schedul weight execut time dec schedul concis perform measur ratio block rollout schedul execut time number time block execut block dec schedul execut time number time block execut mean faster run time part schedul would give smaller ratio schedul ratio schedul ratio random random tr orig tr dec tr tabl ratio weight execut time rollout schedul dec schedul ratio less one mean rollout outperform dec schedul rollout schedul far outperform random schedul slower dec ad rollout random abl achiev run time slower dec schedul use orig dec model outperform dec schedul use orig dec rollout produc schedul faster dec schedul averag although improv may seem small dec schedul known make optim choic time block size less stefanovi rollout test applu rather entir spec benchmark suit due lengthi comput time rollout costli perform rollout instruct wherea greedi schedul algorithm time requir perform five run random sinc dec orig determinist one run necessari also ran random schedul time number report geometr mean ratio across five run part motiv behind use rollout schedul obtain fast schedul without spend time build precis heurist mind explor random close follow experi evalu number rollout experi consid perform vari number ofrollout test rollout per candid instruct also vari metric choos among candid instead alway choos instruct best averag perform also experi select instruct absolut best run time among rollout hypothes select absolut best path might lead better perform overal experi perform basic block size less applu figur show perform rollout schedul function number rollout perform assess way ratio weight execut mcgovern moss perform number rollout number rollout figur perform rollout schedul random model function number rollout choic evalu function time thu lower number better data point repres geometr mean five differ run differ perform one rollout five rollout use averag choic rollout versu howev differ rollout rollout versu indic tradeoff schedul qualiti number rollout also choos instruct best rollout schedul yield better perform number rollout hypothes due stochast natur rollout schedul choos instruct repeat rollout process choos instruct absolut best rollout guarante schedul find permut instruct next rollout choos instruct best averag rollout schedul better chanc find good schedul next rollout although rollout schedul perform quit well extrem long schedul time major drawback use rollout per block took hour schedul one program unless aspect improv rollout cannot use block commerci schedul evalu propos machin architectur howev rollout schedul perform high rollout could use optim schedul import long run time frequent execut block within program reinforc learn result overview reinforc learn rl collect method discov near optim solut stochast sequenti decis problem sutton barto reinforc learn system requir teacher specifi correct action instead learn agent tri differ action observ consequ determin action best specif reinforc learn framework learn agent interact environ seri discret time step time agent state denot st choos action denot caus environ transit state st emit reward denot rt next state reward depend preced state action may depend stochast fashion object learn possibl stochast map state action call polici maxim cumul discount reward receiv agent precis object choos action maxim expect return itt discount rate paramet schedul straight line code use rl rollout common solut strategi approxim optim valu function map state maxim expect return obtain start state take best action paper use tempor differ td learn sutton method approxim repres tabl entri everi state transit state st state st action reward rt estim valu function st updat posit step size paramet experiment result scheeff et al previous experi reinforc learn domain howev result good hope find right reward structur difficult part use rl domain reward base number cycl execut block work well punish learner long block normal effect scheeff et al reward base cycl per instruct cpi howev learn reward also work well block unavoid idl time other reward base sole cpi account aspect account variat across block gave rl schedul final reward time execut block max minimum weight critic path inst ucti ns schedul receiv reward zero unless schedul complet processor issu two instruct time number instruct divid give absolut lower bound run time weight critic path wcp help solv problem size block easier harder schedul other block harder execut anoth block size wcp tend higher thu caus learner get differ reward wcp correl predict number execut cycl dec schedul number instruct divid also correl dec schedul futur experi use weight combin two featur comput reward supervis learn result present moss et al rl system learn preferenti valu function candid instruct instead learn valu instruct instruct rl learn valu choos instruct instruct state space consist tupl featur current partial schedul two candid instruct featur deriv knowledg dec simul featur intuit import summar tabl previou experi moss et al show actual valu wcp matter much rel valu thu featur use signum differ valu two candid instruct signum return depend whether valu less equal greater zero use represent rl state space consist follow tupl given candid instruct partial schedul state vec odd ic ic wcp wcp sc yield uniqu state figur show exampl partial schedul set candid instruct result state rl system rl schedul learn state choic made last choic point trajectori given final reward even instruct schedul point valu multipl state updat time step instruct chosen affect prefer function multipl state mcgovern moss heurist name heurist descript intuit use odd partial odd current number instruct sched true interest schedul inul odd even struction dual issu previou instruct instruct class ic alpha instruct divid instruct class exinto equival class respect ecut certain execut pipelin time properti etc weight critic path wcp height instruct dag instruct longer critic path length longest chain instruc schedul first sinc affect tion depend one edg lower bound schedul cost weight expect latenc result produc instruct actual dual instruct dual issu pre odd partial true import viou schedul instruct find instruct one issu cycl previou schedul instruct max delay earliest cycl instruct want schedul instruct begin execut rel current cy data function unit avail cle take account wait earliest put function unit becom avail tabl featur instruct partial schedul le candid instruct state rl system state label state ab state vec ac state vec bc state vec ba state vec ca state vec cb state vec figur left graphic depict partial schedul three candid instruct tabl right show rl system make state exampl use partial schedul candid instruct shown figur schedul instruct rl system would backup valu ab ac opposit valu ba ca use system perform leav one cross valid across block spec benchmark suit block instruct broken block less memori limit dec simul true two applic applu fpppp rl system train onlin applic use greedi explor method repeat differ time hold one program spec train time evalu greedi polici learn rl system program held tie broken randomli perform assess way result benchmark shown tabl overal rl schedul perform slower dec geometr mean applic suit block although rl system outperform dec schedul overal significantli outperform dec larg block applu big fpppp big conclus advantag rl schedul perform task speed fact reli heurist train run much faster rollout perform came close perform dec schedul schedul straight line code use rl rollout app ratio app ratio app ratio app ratio applu applu big apsi ccl compress fpppp fpppp big go hydro ijpeg li ksim mgrid perl su cor swim tomcatv turb vortex wave tabl perform greedi rl schedul applic spec leav one cross valid run compar dec applic whose run time better dec shown ital system multipl architectur test rl could provid good schedul minim setup train demonstr two method instruct schedul reli heurist perform quit well futur work could address tie two method togeth retain speed rl learner issu global instruct schedul schedul loop valid techniqu architectur acknowledg thank john cavazo darko stefanovid set simul prior work domain along paul utgoff doina precup carla brodley david scheeff also wish thank andrew barto andrew fagg doina precup comment earlier version paper work support part nation physic scienc consortium lockhe martin advanc technolog lab nsf grant iri roder grupen andrew barto thank variou peopl digit equip corpor dec schedul atom program instrument tool srivastava eustac essenti work also thank sun microsystem hewlett packard support refer bertseka differenti train rollout polici proc th allerton confer commun control comput allerton park ill bertseka tsitsikli wu rollout algorithm combinatori optim journal heurist dec dec chip aa microprocessor hardwar refer manual first edit ed maynard digit equip corpor moss utgoff cavazo precup stefanovid brodley scheeff learn schedul straight line code proceed advanc neural inform process system proceed nip mit press scheeff brodley moss cavazo stefanovid appli reinforc learn instruct schedul within basic block technic report univers massachusett amherst site alpha architectur refer manual maynard digit equip corpor srivastava eustac atom system bhild custom program analysi tool proc acm sigplan conf prog lang design impl pp stefanovid charact instruct schedul problem univers massachusett amherst sutton learn predict method tempor differ machin learn sutton barto reinforc learn introduct cambridg mit press tesauro galperin line polici improv use mont carlo search advanc neural inform process proceed ninth confer mit press